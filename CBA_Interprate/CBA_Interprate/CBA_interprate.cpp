#include "CBA_interprate.h"

int g_LowLightGamma[1024] =
{
	0,1,
	1,2,3,4,4,5,5,6,7,8,8,9,9,10,11,12,12,13,13,14,15,16,16,17,17,18,19,20,20,21,21,22,
	23,23,24,24,25,26,27,27,28,28,29,29,30,30,31,32,32,33,33,34,35,36,36,36,37,37,38,39,40,40,40,41,
	42,43,43,44,44,45,45,45,46,47,47,48,48,49,49,50,50,51,52,53,53,53,54,55,55,56,56,57,57,57,58,59,
	59,60,60,61,61,61,62,63,63,64,64,65,65,65,66,67,67,68,68,69,69,69,70,71,71,72,72,73,73,73,74,74,
	74,75,76,76,76,77,77,77,78,79,79,80,80,81,81,81,82,83,83,83,84,84,85,85,85,85,86,86,87,87,88,89,
	89,89,89,90,90,91,91,91,92,93,93,93,94,94,94,95,96,96,96,97,97,97,98,98,98,99,100,100,100,101,101,101,
	102,102,102,103,104,104,104,105,105,105,105,106,106,107,107,107,108,108,109,109,109,110,110,110,111,111,112,112,113,113,113,113,
	113,114,114,115,115,115,116,116,117,117,117,118,118,118,118,119,120,120,120,120,121,121,121,122,122,122,122,123,124,124,124,124,
	125,125,125,126,126,126,126,127,128,128,128,128,129,129,130,130,130,130,130,131,131,131,131,132,133,133,133,133,134,134,134,134,
	134,135,135,136,136,136,137,137,137,137,138,138,138,139,139,139,139,140,140,140,141,141,142,142,142,142,142,143,143,143,143,144,
	144,144,145,145,146,146,146,146,146,147,147,147,147,148,148,148,149,149,149,149,150,150,150,150,150,151,151,152,152,152,153,153,
	153,153,154,154,154,154,154,155,155,155,155,156,156,156,157,157,157,157,158,158,158,158,158,159,159,159,159,160,160,160,161,161,
	161,161,162,162,162,162,162,163,163,163,163,164,164,164,165,165,165,165,166,166,166,166,166,167,167,167,167,167,167,168,168,168,
	169,169,169,169,170,170,170,170,170,171,171,171,171,172,172,172,172,172,173,173,173,173,174,174,174,174,174,175,175,175,175,176,
	176,176,176,176,177,177,177,177,178,178,178,178,178,179,179,179,179,179,179,180,180,180,181,181,181,181,181,181,182,182,182,182,
	182,183,183,183,183,184,184,184,184,184,185,185,185,185,186,186,186,186,186,186,186,187,187,187,187,187,187,188,188,188,189,189,
	189,189,189,189,190,190,190,190,190,191,191,191,191,191,191,192,192,192,192,192,193,193,193,193,194,194,194,194,194,194,194,195,
	195,195,195,195,195,196,196,196,196,196,197,197,197,197,197,197,198,198,198,198,198,198,198,199,199,199,199,200,200,200,200,200,
	201,201,201,201,201,201,202,202,202,202,202,202,202,203,203,203,203,203,203,204,204,204,204,204,205,205,205,205,205,205,206,206,
	206,206,206,206,206,206,206,207,207,207,207,207,207,208,208,208,208,208,209,209,209,209,209,209,210,210,210,210,210,210,210,211,
	211,211,211,211,211,211,211,212,212,212,212,212,213,213,213,213,213,213,214,214,214,214,214,214,214,214,215,215,215,215,215,215,
	215,216,216,216,216,216,216,216,216,217,217,217,217,217,218,218,218,218,218,218,218,218,219,219,219,219,219,219,219,220,220,220,
	220,220,220,220,220,221,221,221,221,221,221,221,222,222,222,222,222,222,223,223,223,223,223,223,223,223,223,224,224,224,224,224,
	224,224,224,225,225,225,225,225,225,225,226,226,226,226,226,226,226,226,227,227,227,227,227,227,227,227,227,228,228,228,228,228,
	228,228,228,229,229,229,229,229,229,229,230,230,230,230,230,230,230,230,231,231,231,231,231,231,231,231,231,232,232,232,232,232,
	232,232,232,233,233,233,233,233,233,233,234,234,234,234,234,234,234,234,234,234,235,235,235,235,235,235,235,235,235,236,236,236,
	236,236,236,236,236,237,237,237,237,237,237,237,237,237,238,238,238,238,238,238,238,238,239,239,239,239,239,239,239,239,239,239,
	239,240,240,240,240,240,240,240,240,240,240,241,241,241,241,241,241,241,242,242,242,242,242,242,242,242,242,242,243,243,243,243,
	243,243,243,243,243,243,243,244,244,244,244,244,244,244,244,244,244,245,245,245,245,245,245,245,245,245,246,246,246,246,246,246,
	246,246,246,246,247,247,247,247,247,247,247,247,247,247,247,248,248,248,248,248,248,248,248,248,248,249,249,249,249,249,249,249,
	249,249,250,250,250,250,250,250,250,250,250,250,250,250,251,251,251,251,251,251,251,251,251,251,251,252,252,252,252,252,252,252,
	252,252,252,253,253,253,253,253,253,253,253,253,253,253,254,254,254,254,254,254,254,254,254,254,254,254,255,255,255,255
};

/// Gamma 10 to Linear 12 
unsigned int Gamma10toLinear12[] =
{
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
	20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
	40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
	80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
	100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
	120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,
	140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
	180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,
	200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,
	220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,
	260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,
	280,281,282,283,284,285,286,287,288,289,290,291,292,293,295,296,297,298,299,
	300,301,302,303,304,305,306,308,309,310,311,312,313,314,315,317,318,319,
	320,321,322,324,325,326,327,328,329,331,332,333,334,335,337,338,339,
	340,342,343,344,345,346,348,349,350,352,353,354,355,357,358,359,
	361,362,363,364,366,367,368,370,371,372,374,375,377,378,379,
	381,382,383,385,386,388,389,390,392,393,395,396,397,399,
	400,402,403,405,406,408,409,411,412,414,415,417,418,
	420,421,423,424,426,427,429,430,432,433,435,437,438,
	440,441,443,445,446,448,449,451,453,454,456,458,459,
	461,463,464,466,468,469,471,473,474,476,478,
	480,481,483,485,487,488,490,492,494,495,497,499,
	501,503,504,506,508,510,512,514,515,517,519,
	521,523,525,527,529,531,532,534,536,538,
	540,542,544,546,548,550,552,554,556,558,
	560,562,564,566,568,570,572,574,576,579,
	581,583,585,587,589,591,593,596,598,
	600,602,604,606,609,611,613,615,617,
	620,622,624,626,629,631,633,636,638,
	640,642,645,647,649,652,654,657,659,
	661,664,666,668,671,673,676,678,
	681,683,686,688,691,693,696,698,
	701,703,706,708,711,713,716,719,
	721,724,726,729,732,734,737,
	740,742,745,748,750,753,756,759,
	761,764,767,770,772,775,778,
	781,784,786,789,792,795,798,
	801,804,807,809,812,815,818,
	821,824,827,830,833,836,839,
	842,845,848,851,855,858,
	861,864,867,870,873,876,
	880,883,886,889,892,896,899,
	902,905,909,912,915,918,
	922,925,928,932,935,939,
	942,945,949,952,956,959,
	963,966,970,973,977,
	980,984,987,991,994,998,
	1002,1005,1009,1013,1016,
	1020,1024,1027,1031,1035,1038,
	1042,1046,1050,1054,1057,1061,1065,1069,1073,1077,1081,1084,1088,1092,1096,1100,
	1104,1108,1112,1116,1120,1124,1128,1132,1137,1141,1145,1149,1153,1157,1161,1166,
	1170,1174,1178,1183,1187,1191,1195,1200,1204,1209,1213,1217,1222,1226,1231,1235,
	1239,1244,1248,1253,1257,1262,1267,1271,1276,1280,1285,1290,1294,1299,1304,1308,
	1313,1318,1323,1327,1332,1337,1342,1347,1352,1357,1361,1366,1371,1376,1381,1386,
	1391,1396,1401,1406,1411,1417,1422,1427,1432,1437,1442,1448,1453,1458,1463,1469,
	1474,1479,1485,1490,1495,1501,1506,1512,1517,1523,1528,1534,1539,1545,1550,1556,
	1562,1567,1573,1579,1584,1590,1596,1602,1607,1613,1619,1625,1631,1637,1643,1649,
	1655,1661,1667,1673,1679,1685,1691,1697,1703,1709,1715,1722,1728,1734,1740,1747,
	1753,1759,1766,1772,1778,1785,1791,1798,1804,1811,1817,1824,1831,1837,1844,1850,
	1857,1864,1871,1877,1884,1891,1898,1905,1912,1918,1925,1932,1939,1946,1953,1961,
	1968,1975,1982,1989,1996,2003,2011,2018,2025,2033,2040,2047,2055,2062,2070,2077,
	2085,2092,2100,2107,2115,2123,2130,2138,2146,2153,2161,2169,2177,2185,2193,2201,
	2209,2217,2225,2233,2241,2249,2257,2265,2273,2282,2290,2298,2306,2315,2323,2332,
	2340,2348,2357,2365,2374,2383,2391,2400,2409,2417,2426,2435,2444,2452,2461,2470,
	2479,2488,2497,2506,2515,2524,2533,2543,2552,2561,2570,2580,2589,2598,2608,2617,
	2627,2636,2646,2655,2665,2674,2684,2694,2704,2713,2723,2733,2743,2753,2763,2773,
	2783,2793,2803,2813,2823,2833,2844,2854,2864,2875,2885,2895,2906,2916,2927,2938,
	2948,2959,2970,2980,2991,3002,3013,3024,3035,3046,3057,3068,3079,3090,3101,3112,
	3124,3135,3146,3158,3169,3180,3192,3204,3215,3227,3238,3250,3262,3274,3286,3297,
	3309,3321,3333,3345,3357,3370,3382,3394,3406,3419,3431,3443,3456,3468,3481,3493,
	3506,3519,3532,3544,3557,3570,3583,3596,3609,3622,3635,3648,3661,3675,3688,3701,
	3715,3728,3742,3755,3769,3782,3796,3810,3824,3837,3851,3865,3879,3893,3907,3921,
	3936,3950,3964,3978,3993,4007,4022,4036,4051,4066,4080,4095
};

// 12转10的Gama查找表
unsigned int Linear12toGamma10[] =
{
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
	20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
	40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
	80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
	100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
	120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,
	140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
	180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,
	200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,
	220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,
	260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,
	280,281,282,283,284,285,286,287,288,289,290,291,292,293,293,294,295,296,297,298,
	299,300,301,302,303,304,305,305,306,307,308,309,310,311,312,313,313,314,315,316,
	317,318,319,320,320,321,322,323,324,325,325,326,327,328,329,330,330,331,332,333,
	334,335,335,336,337,338,339,339,340,341,342,343,343,344,345,346,346,347,348,349,
	350,350,351,352,353,353,354,355,356,356,357,358,359,359,360,361,362,362,363,364,
	365,365,366,367,367,368,369,370,370,371,372,372,373,374,375,375,376,377,377,378,
	379,379,380,381,382,382,383,384,384,385,386,386,387,388,388,389,390,390,391,392,
	392,393,394,394,395,396,396,397,398,398,399,399,400,401,401,402,403,403,404,405,
	405,406,406,407,408,408,409,410,410,411,411,412,413,413,414,414,415,416,416,417,
	417,418,419,419,420,420,421,422,422,423,423,424,425,425,426,426,427,428,428,429,
	429,430,430,431,432,432,433,433,434,434,435,436,436,437,437,438,438,439,439,440,
	441,441,442,442,443,443,444,444,445,446,446,447,447,448,448,449,449,450,450,451,
	451,452,452,453,454,454,455,455,456,456,457,457,458,458,459,459,460,460,461,461,
	462,462,463,463,464,464,465,465,466,466,467,467,468,468,469,469,470,470,471,471,
	472,472,473,473,474,474,475,475,476,476,477,477,478,478,479,479,480,480,481,481,
	482,482,483,483,484,484,485,485,485,486,486,487,487,488,488,489,489,490,490,491,
	491,492,492,492,493,493,494,494,495,495,496,496,497,497,497,498,498,499,499,500,
	500,501,501,501,502,502,503,503,504,504,505,505,505,506,506,507,507,508,508,509,
	509,509,510,510,511,511,512,512,512,513,513,514,514,515,515,515,516,516,517,517,
	517,518,518,519,519,520,520,520,521,521,522,522,522,523,523,524,524,525,525,525,
	526,526,527,527,527,528,528,529,529,529,530,530,531,531,531,532,532,533,533,533,
	534,534,535,535,535,536,536,537,537,537,538,538,538,539,539,540,540,540,541,541,
	542,542,542,543,543,543,544,544,545,545,545,546,546,547,547,547,548,548,548,549,
	549,550,550,550,551,551,551,552,552,553,553,553,554,554,554,555,555,555,556,556,
	557,557,557,558,558,558,559,559,559,560,560,561,561,561,562,562,562,563,563,563,
	564,564,564,565,565,566,566,566,567,567,567,568,568,568,569,569,569,570,570,570,
	571,571,571,572,572,572,573,573,574,574,574,575,575,575,576,576,576,577,577,577,
	578,578,578,579,579,579,580,580,580,581,581,581,582,582,582,583,583,583,584,584,
	584,585,585,585,586,586,586,587,587,587,588,588,588,589,589,589,589,590,590,590,
	591,591,591,592,592,592,593,593,593,594,594,594,595,595,595,596,596,596,597,597,
	597,597,598,598,598,599,599,599,600,600,600,601,601,601,602,602,602,602,603,603,
	603,604,604,604,605,605,605,606,606,606,606,607,607,607,608,608,608,609,609,609,
	609,610,610,610,611,611,611,612,612,612,612,613,613,613,614,614,614,615,615,615,
	615,616,616,616,617,617,617,617,618,618,618,619,619,619,620,620,620,620,621,621,
	621,622,622,622,622,623,623,623,624,624,624,624,625,625,625,626,626,626,626,627,
	627,627,628,628,628,628,629,629,629,629,630,630,630,631,631,631,631,632,632,632,
	633,633,633,633,634,634,634,634,635,635,635,636,636,636,636,637,637,637,637,638,
	638,638,639,639,639,639,640,640,640,640,641,641,641,642,642,642,642,643,643,643,
	643,644,644,644,644,645,645,645,646,646,646,646,647,647,647,647,648,648,648,648,
	649,649,649,649,650,650,650,651,651,651,651,652,652,652,652,653,653,653,653,654,
	654,654,654,655,655,655,655,656,656,656,656,657,657,657,657,658,658,658,658,659,
	659,659,659,660,660,660,660,661,661,661,661,662,662,662,662,663,663,663,663,664,
	664,664,664,665,665,665,665,666,666,666,666,667,667,667,667,668,668,668,668,669,
	669,669,669,670,670,670,670,671,671,671,671,671,672,672,672,672,673,673,673,673,
	674,674,674,674,675,675,675,675,676,676,676,676,677,677,677,677,677,678,678,678,
	678,679,679,679,679,680,680,680,680,680,681,681,681,681,682,682,682,682,683,683,
	683,683,684,684,684,684,684,685,685,685,685,686,686,686,686,686,687,687,687,687,
	688,688,688,688,689,689,689,689,689,690,690,690,690,691,691,691,691,691,692,692,
	692,692,693,693,693,693,693,694,694,694,694,695,695,695,695,695,696,696,696,696,
	697,697,697,697,697,698,698,698,698,699,699,699,699,699,700,700,700,700,700,701,
	701,701,701,702,702,702,702,702,703,703,703,703,704,704,704,704,704,705,705,705,
	705,705,706,706,706,706,706,707,707,707,707,708,708,708,708,708,709,709,709,709,
	709,710,710,710,710,710,711,711,711,711,712,712,712,712,712,713,713,713,713,713,
	714,714,714,714,714,715,715,715,715,715,716,716,716,716,716,717,717,717,717,718,
	718,718,718,718,719,719,719,719,719,720,720,720,720,720,721,721,721,721,721,722,
	722,722,722,722,723,723,723,723,723,724,724,724,724,724,725,725,725,725,725,726,
	726,726,726,726,727,727,727,727,727,728,728,728,728,728,728,729,729,729,729,729,
	730,730,730,730,730,731,731,731,731,731,732,732,732,732,732,733,733,733,733,733,
	734,734,734,734,734,734,735,735,735,735,735,736,736,736,736,736,737,737,737,737,
	737,738,738,738,738,738,738,739,739,739,739,739,740,740,740,740,740,741,741,741,
	741,741,742,742,742,742,742,742,743,743,743,743,743,744,744,744,744,744,744,745,
	745,745,745,745,746,746,746,746,746,747,747,747,747,747,747,748,748,748,748,748,
	749,749,749,749,749,749,750,750,750,750,750,751,751,751,751,751,751,752,752,752,
	752,752,752,753,753,753,753,753,754,754,754,754,754,754,755,755,755,755,755,756,
	756,756,756,756,756,757,757,757,757,757,757,758,758,758,758,758,759,759,759,759,
	759,759,760,760,760,760,760,760,761,761,761,761,761,762,762,762,762,762,762,763,
	763,763,763,763,763,764,764,764,764,764,764,765,765,765,765,765,765,766,766,766,
	766,766,767,767,767,767,767,767,768,768,768,768,768,768,769,769,769,769,769,769,
	770,770,770,770,770,770,771,771,771,771,771,771,772,772,772,772,772,772,773,773,
	773,773,773,773,774,774,774,774,774,774,775,775,775,775,775,775,776,776,776,776,
	776,776,777,777,777,777,777,777,778,778,778,778,778,778,779,779,779,779,779,779,
	780,780,780,780,780,780,780,781,781,781,781,781,781,782,782,782,782,782,782,783,
	783,783,783,783,783,784,784,784,784,784,784,785,785,785,785,785,785,785,786,786,
	786,786,786,786,787,787,787,787,787,787,788,788,788,788,788,788,788,789,789,789,
	789,789,789,790,790,790,790,790,790,791,791,791,791,791,791,791,792,792,792,792,
	792,792,793,793,793,793,793,793,793,794,794,794,794,794,794,795,795,795,795,795,
	795,795,796,796,796,796,796,796,797,797,797,797,797,797,797,798,798,798,798,798,
	798,799,799,799,799,799,799,799,800,800,800,800,800,800,801,801,801,801,801,801,
	801,802,802,802,802,802,802,802,803,803,803,803,803,803,804,804,804,804,804,804,
	804,805,805,805,805,805,805,805,806,806,806,806,806,806,807,807,807,807,807,807,
	807,808,808,808,808,808,808,808,809,809,809,809,809,809,809,810,810,810,810,810,
	810,810,811,811,811,811,811,811,811,812,812,812,812,812,812,812,813,813,813,813,
	813,813,814,814,814,814,814,814,814,815,815,815,815,815,815,815,816,816,816,816,
	816,816,816,817,817,817,817,817,817,817,818,818,818,818,818,818,818,819,819,819,
	819,819,819,819,819,820,820,820,820,820,820,820,821,821,821,821,821,821,821,822,
	822,822,822,822,822,822,823,823,823,823,823,823,823,824,824,824,824,824,824,824,
	825,825,825,825,825,825,825,825,826,826,826,826,826,826,826,827,827,827,827,827,
	827,827,828,828,828,828,828,828,828,829,829,829,829,829,829,829,829,830,830,830,
	830,830,830,830,831,831,831,831,831,831,831,831,832,832,832,832,832,832,832,833,
	833,833,833,833,833,833,834,834,834,834,834,834,834,834,835,835,835,835,835,835,
	835,836,836,836,836,836,836,836,836,837,837,837,837,837,837,837,838,838,838,838,
	838,838,838,838,839,839,839,839,839,839,839,839,840,840,840,840,840,840,840,841,
	841,841,841,841,841,841,841,842,842,842,842,842,842,842,842,843,843,843,843,843,
	843,843,844,844,844,844,844,844,844,844,845,845,845,845,845,845,845,845,846,846,
	846,846,846,846,846,846,847,847,847,847,847,847,847,848,848,848,848,848,848,848,
	848,849,849,849,849,849,849,849,849,850,850,850,850,850,850,850,850,851,851,851,
	851,851,851,851,851,852,852,852,852,852,852,852,852,853,853,853,853,853,853,853,
	853,854,854,854,854,854,854,854,854,855,855,855,855,855,855,855,855,856,856,856,
	856,856,856,856,856,857,857,857,857,857,857,857,857,858,858,858,858,858,858,858,
	858,858,859,859,859,859,859,859,859,859,860,860,860,860,860,860,860,860,861,861,
	861,861,861,861,861,861,862,862,862,862,862,862,862,862,863,863,863,863,863,863,
	863,863,863,864,864,864,864,864,864,864,864,865,865,865,865,865,865,865,865,866,
	866,866,866,866,866,866,866,866,867,867,867,867,867,867,867,867,868,868,868,868,
	868,868,868,868,868,869,869,869,869,869,869,869,869,870,870,870,870,870,870,870,
	870,870,871,871,871,871,871,871,871,871,872,872,872,872,872,872,872,872,872,873,
	873,873,873,873,873,873,873,874,874,874,874,874,874,874,874,874,875,875,875,875,
	875,875,875,875,875,876,876,876,876,876,876,876,876,877,877,877,877,877,877,877,
	877,877,878,878,878,878,878,878,878,878,878,879,879,879,879,879,879,879,879,879,
	880,880,880,880,880,880,880,880,881,881,881,881,881,881,881,881,881,882,882,882,
	882,882,882,882,882,882,883,883,883,883,883,883,883,883,883,884,884,884,884,884,
	884,884,884,884,885,885,885,885,885,885,885,885,885,886,886,886,886,886,886,886,
	886,886,887,887,887,887,887,887,887,887,887,888,888,888,888,888,888,888,888,888,
	889,889,889,889,889,889,889,889,889,890,890,890,890,890,890,890,890,890,891,891,
	891,891,891,891,891,891,891,891,892,892,892,892,892,892,892,892,892,893,893,893,
	893,893,893,893,893,893,894,894,894,894,894,894,894,894,894,895,895,895,895,895,
	895,895,895,895,895,896,896,896,896,896,896,896,896,896,897,897,897,897,897,897,
	897,897,897,898,898,898,898,898,898,898,898,898,898,899,899,899,899,899,899,899,
	899,899,900,900,900,900,900,900,900,900,900,900,901,901,901,901,901,901,901,901,
	901,902,902,902,902,902,902,902,902,902,902,903,903,903,903,903,903,903,903,903,
	904,904,904,904,904,904,904,904,904,904,905,905,905,905,905,905,905,905,905,905,
	906,906,906,906,906,906,906,906,906,907,907,907,907,907,907,907,907,907,907,908,
	908,908,908,908,908,908,908,908,908,909,909,909,909,909,909,909,909,909,909,910,
	910,910,910,910,910,910,910,910,910,911,911,911,911,911,911,911,911,911,912,912,
	912,912,912,912,912,912,912,912,913,913,913,913,913,913,913,913,913,913,914,914,
	914,914,914,914,914,914,914,914,915,915,915,915,915,915,915,915,915,915,916,916,
	916,916,916,916,916,916,916,916,917,917,917,917,917,917,917,917,917,917,918,918,
	918,918,918,918,918,918,918,918,919,919,919,919,919,919,919,919,919,919,919,920,
	920,920,920,920,920,920,920,920,920,921,921,921,921,921,921,921,921,921,921,922,
	922,922,922,922,922,922,922,922,922,923,923,923,923,923,923,923,923,923,923,923,
	924,924,924,924,924,924,924,924,924,924,925,925,925,925,925,925,925,925,925,925,
	926,926,926,926,926,926,926,926,926,926,926,927,927,927,927,927,927,927,927,927,
	927,928,928,928,928,928,928,928,928,928,928,928,929,929,929,929,929,929,929,929,
	929,929,930,930,930,930,930,930,930,930,930,930,930,931,931,931,931,931,931,931,
	931,931,931,932,932,932,932,932,932,932,932,932,932,932,933,933,933,933,933,933,
	933,933,933,933,933,934,934,934,934,934,934,934,934,934,934,935,935,935,935,935,
	935,935,935,935,935,935,936,936,936,936,936,936,936,936,936,936,936,937,937,937,
	937,937,937,937,937,937,937,937,938,938,938,938,938,938,938,938,938,938,938,939,
	939,939,939,939,939,939,939,939,939,939,940,940,940,940,940,940,940,940,940,940,
	940,941,941,941,941,941,941,941,941,941,941,941,942,942,942,942,942,942,942,942,
	942,942,942,943,943,943,943,943,943,943,943,943,943,943,944,944,944,944,944,944,
	944,944,944,944,944,945,945,945,945,945,945,945,945,945,945,945,946,946,946,946,
	946,946,946,946,946,946,946,947,947,947,947,947,947,947,947,947,947,947,948,948,
	948,948,948,948,948,948,948,948,948,948,949,949,949,949,949,949,949,949,949,949,
	949,950,950,950,950,950,950,950,950,950,950,950,951,951,951,951,951,951,951,951,
	951,951,951,951,952,952,952,952,952,952,952,952,952,952,952,953,953,953,953,953,
	953,953,953,953,953,953,953,954,954,954,954,954,954,954,954,954,954,954,955,955,
	955,955,955,955,955,955,955,955,955,955,956,956,956,956,956,956,956,956,956,956,
	956,957,957,957,957,957,957,957,957,957,957,957,957,958,958,958,958,958,958,958,
	958,958,958,958,958,959,959,959,959,959,959,959,959,959,959,959,960,960,960,960,
	960,960,960,960,960,960,960,960,961,961,961,961,961,961,961,961,961,961,961,961,
	962,962,962,962,962,962,962,962,962,962,962,962,963,963,963,963,963,963,963,963,
	963,963,963,963,964,964,964,964,964,964,964,964,964,964,964,964,965,965,965,965,
	965,965,965,965,965,965,965,965,966,966,966,966,966,966,966,966,966,966,966,966,
	967,967,967,967,967,967,967,967,967,967,967,967,968,968,968,968,968,968,968,968,
	968,968,968,968,969,969,969,969,969,969,969,969,969,969,969,969,970,970,970,970,
	970,970,970,970,970,970,970,970,971,971,971,971,971,971,971,971,971,971,971,971,
	971,972,972,972,972,972,972,972,972,972,972,972,972,973,973,973,973,973,973,973,
	973,973,973,973,973,974,974,974,974,974,974,974,974,974,974,974,974,974,975,975,
	975,975,975,975,975,975,975,975,975,975,976,976,976,976,976,976,976,976,976,976,
	976,976,976,977,977,977,977,977,977,977,977,977,977,977,977,978,978,978,978,978,
	978,978,978,978,978,978,978,978,979,979,979,979,979,979,979,979,979,979,979,979,
	980,980,980,980,980,980,980,980,980,980,980,980,980,981,981,981,981,981,981,981,
	981,981,981,981,981,981,982,982,982,982,982,982,982,982,982,982,982,982,983,983,
	983,983,983,983,983,983,983,983,983,983,983,984,984,984,984,984,984,984,984,984,
	984,984,984,984,985,985,985,985,985,985,985,985,985,985,985,985,985,986,986,986,
	986,986,986,986,986,986,986,986,986,986,987,987,987,987,987,987,987,987,987,987,
	987,987,987,988,988,988,988,988,988,988,988,988,988,988,988,988,989,989,989,989,
	989,989,989,989,989,989,989,989,989,990,990,990,990,990,990,990,990,990,990,990,
	990,990,991,991,991,991,991,991,991,991,991,991,991,991,991,992,992,992,992,992,
	992,992,992,992,992,992,992,992,993,993,993,993,993,993,993,993,993,993,993,993,
	993,993,994,994,994,994,994,994,994,994,994,994,994,994,994,995,995,995,995,995,
	995,995,995,995,995,995,995,995,996,996,996,996,996,996,996,996,996,996,996,996,
	996,996,997,997,997,997,997,997,997,997,997,997,997,997,997,998,998,998,998,998,
	998,998,998,998,998,998,998,998,998,999,999,999,999,999,999,999,999,999,999,999,
	999,999,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1001,
	1001,1001,1001,1001,1001,1001,1001,1001,1001,1001,1001,1001,1001,1002,1002,1002,1002,
	1002,1002,1002,1002,1002,1002,1002,1002,1002,1003,1003,1003,1003,1003,1003,1003,1003,
	1003,1003,1003,1003,1003,1003,1004,1004,1004,1004,1004,1004,1004,1004,1004,1004,1004,
	1004,1004,1004,1005,1005,1005,1005,1005,1005,1005,1005,1005,1005,1005,1005,1005,1005,
	1006,1006,1006,1006,1006,1006,1006,1006,1006,1006,1006,1006,1006,1006,1007,1007,1007,
	1007,1007,1007,1007,1007,1007,1007,1007,1007,1007,1007,1008,1008,1008,1008,1008,1008,
	1008,1008,1008,1008,1008,1008,1008,1008,1009,1009,1009,1009,1009,1009,1009,1009,1009,
	1009,1009,1009,1009,1009,1010,1010,1010,1010,1010,1010,1010,1010,1010,1010,1010,1010,
	1010,1010,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1012,
	1012,1012,1012,1012,1012,1012,1012,1012,1012,1012,1012,1012,1012,1013,1013,1013,1013,
	1013,1013,1013,1013,1013,1013,1013,1013,1013,1013,1014,1014,1014,1014,1014,1014,1014,
	1014,1014,1014,1014,1014,1014,1014,1014,1015,1015,1015,1015,1015,1015,1015,1015,1015,
	1015,1015,1015,1015,1015,1016,1016,1016,1016,1016,1016,1016,1016,1016,1016,1016,1016,
	1016,1016,1016,1017,1017,1017,1017,1017,1017,1017,1017,1017,1017,1017,1017,1017,1017,
	1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1018,1019,1019,
	1019,1019,1019,1019,1019,1019,1019,1019,1019,1019,1019,1019,1020,1020,1020,1020,1020,
	1020,1020,1020,1020,1020,1020,1020,1020,1020,1020,1021,1021,1021,1021,1021,1021,1021,
	1021,1021,1021,1021,1021,1021,1021,1022,1022,1022,1022,1022,1022,1022,1022,1022,1022,
	1022,1022,1022,1022,1022,1023,1023,1023,1023,1023,1023,1023,1023
};
int g_NormalLightGamma[1024] =
{
	0,0,
	1,1,2,2,3,3,4,4,4,5,5,5,6,6,6,7,7,8,8,9,9,9,10,10,10,11,11,12,12,13,13,14,
	14,15,16,16,17,17,18,19,19,20,21,21,22,23,24,25,25,26,27,28,29,30,31,31,32,33,34,35,35,36,37,38,
	39,39,40,41,41,42,43,43,44,45,45,46,46,47,48,49,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,
	60,60,61,62,62,63,64,64,65,65,66,67,68,68,69,69,70,71,71,72,73,73,73,74,75,76,76,77,77,78,78,79,
	80,80,81,81,82,83,83,84,84,85,85,85,86,86,87,88,89,89,89,90,91,91,92,93,93,93,94,94,95,95,96,97,
	97,97,98,98,99,99,100,100,101,101,101,101,102,102,103,103,104,105,105,105,106,106,107,107,108,108,109,109,109,110,110,110,
	111,111,112,113,113,113,113,114,114,115,115,115,116,117,117,117,117,118,118,119,119,119,120,120,121,121,121,122,122,122,123,123,
	124,124,125,125,125,125,126,126,126,127,128,128,128,128,129,129,130,130,130,130,130,131,131,132,132,132,133,133,134,134,134,134,
	134,135,135,136,136,136,137,137,137,137,138,138,138,139,139,139,139,140,141,141,141,141,142,142,142,142,142,143,143,143,143,144,
	145,145,145,145,146,146,146,146,146,147,147,147,147,148,148,148,149,149,149,149,150,150,150,150,150,151,151,152,152,152,153,153,
	153,153,154,154,154,154,154,155,155,155,155,156,156,156,156,156,157,157,157,157,158,158,158,158,158,159,159,159,159,160,160,160,
	161,161,161,161,162,162,162,162,162,162,162,163,163,163,163,164,164,164,165,165,165,165,165,165,166,166,166,166,166,167,167,167,
	167,167,167,168,168,168,169,169,169,169,169,169,170,170,170,170,170,171,171,171,171,171,171,172,172,172,173,173,173,173,173,173,
	174,174,174,174,174,174,174,175,175,175,175,175,175,176,176,176,177,177,177,177,177,177,178,178,178,178,178,178,178,179,179,179,
	179,179,179,180,180,180,180,180,181,181,181,181,181,181,182,182,182,182,182,182,182,183,183,183,183,183,183,184,184,184,184,184,
	185,185,185,185,185,185,186,186,186,186,186,186,186,187,187,187,187,187,187,188,188,188,188,188,189,189,189,189,189,189,189,189,
	190,190,190,190,190,190,190,191,191,191,191,191,191,192,192,192,192,192,193,193,193,193,193,193,194,194,194,194,194,194,194,195,
	195,195,195,195,195,196,196,196,196,196,196,196,197,197,197,197,197,197,198,198,198,198,198,198,198,199,199,199,199,199,199,200,
	200,200,200,200,201,201,201,201,201,201,202,202,202,202,202,202,202,202,202,203,203,203,203,203,203,204,204,204,204,204,205,205,
	205,205,205,205,205,205,206,206,206,206,206,206,206,207,207,207,207,207,207,208,208,208,208,208,209,209,209,209,209,209,209,209,
	210,210,210,210,210,210,210,211,211,211,211,211,211,211,211,212,212,212,212,212,213,213,213,213,213,213,214,214,214,214,214,214,
	214,214,215,215,215,215,215,215,215,216,216,216,216,216,216,216,216,217,217,217,217,217,217,217,218,218,218,218,218,218,219,219,
	219,219,219,219,219,219,219,220,220,220,220,220,220,221,221,221,221,221,221,221,222,222,222,222,222,222,222,222,223,223,223,223,
	223,223,223,223,223,224,224,224,224,224,224,224,224,225,225,225,225,225,226,226,226,226,226,226,226,226,227,227,227,227,227,227,
	227,227,227,228,228,228,228,228,228,228,228,229,229,229,229,229,229,229,229,229,230,230,230,230,230,230,230,230,231,231,231,231,
	231,231,231,231,231,232,232,232,232,232,232,232,232,233,233,233,233,233,233,233,233,233,234,234,234,234,234,234,234,234,235,235,
	235,235,235,235,235,235,235,236,236,236,236,236,236,236,236,236,236,237,237,237,237,237,237,237,237,237,238,238,238,238,238,238,
	238,238,239,239,239,239,239,239,239,239,239,239,239,240,240,240,240,240,240,240,240,241,241,241,241,241,241,241,241,241,242,242,
	242,242,242,242,242,242,242,242,243,243,243,243,243,243,243,243,243,243,243,244,244,244,244,244,244,244,244,244,244,245,245,245,
	245,245,245,245,246,246,246,246,246,246,246,246,246,246,247,247,247,247,247,247,247,247,247,247,247,248,248,248,248,248,248,248,
	248,248,248,249,249,249,249,249,249,249,249,249,250,250,250,250,250,250,250,250,251,251,251,251,251,251,251,251,251,251,251,252,
	252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,253,254,254,254,254,254,254,254,254,254,254,255,255,255,255
};
//--------------------------------------------------
/**
插值获得全分辨率G分量  
\param   pSrc         26位Raw图原始图像buffer指针
\param   nWidth       图像宽
\paran   nHei         图像高
\Param   pDest        全分辨率G分量图像指针

 return  NULL
*/
//--------------------------------------------------
void InterpolateG(int *pDest,short *pSrc,int nWidth,int nHei,BAYER_TYPE Bayer_type)
{
	if (pSrc == NULL || pDest == NULL )
	{
		return ;
	}

	int i = 0;
	int j = 0;

	int eeclassifier = 0;
	int ooclassifier = 0;
	int eepred     = 0;
	int oopred     = 0;

	int PixelPos   = 0;
	int Gradient   = 0;
	int Compensate = 0;

	int neoValue   = 0;
	int noeValue   = 0;

	switch(Bayer_type)
	{
	case BAYER_BG:
    case BAYER_RG:
		for (i = 0 ; i < nHei; i += 2)   //计算偶偶位置G分量
		{
			for (j = 0; j < nWidth; j += 2)
			{
				if (i < 2 || j < 2 || i >= (nHei - 2) || j >=(nWidth - 2))  //边缘处用2*2
				{
					neoValue = (int)((pSrc[i*nWidth + j + 1] + pSrc[(i+1)*nWidth + j] + 0.5)/2); //左侧和下侧值的平均
				}
				else
				{

					Gradient   = pSrc[i*nWidth + j - 1] - pSrc[i*nWidth + j + 1];  // 左侧点减去右侧点
					Compensate = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j])*2 
						- pSrc[(i-1)*nWidth + j - 2]
					- pSrc[(i-1)*nWidth + j + 2]
					- pSrc[(i+1)*nWidth + j - 2]
					- pSrc[(i+1)*nWidth + j + 2];
					eeclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					Gradient   = pSrc[(i+1)*nWidth + j] - pSrc[(i-1)*nWidth + j];   // 下侧点减去上侧点
					Compensate = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1])*2
						- pSrc[(i-2)*nWidth + j - 1]
					- pSrc[(i-2)*nWidth + j + 1]
					- pSrc[(i+2)*nWidth + j - 1]
					- pSrc[(i+2)*nWidth + j + 1];
					ooclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					eepred =  (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1]) << 2;
					oopred =  (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j]) << 2;

					neoValue = (eeclassifier * (oopred/8) + ooclassifier * (eepred/8))/(eeclassifier + ooclassifier);
				}

				neoValue = CLIP12(neoValue);
				//pDest[i*nWidth + j] = Linear12toGamma10[neoValue] * SCALE_VALUE;
				pDest[i*nWidth + j] = neoValue * SCALE_VALUE;
			}
		}


		for (i = 1; i < nHei; i += 2)  //计算奇奇位置G分量
		{
			for (j = 1; j < nWidth; j += 2)
			{
				if (i < 2 || j < 2 || i >=(nHei - 2) || j >= (nWidth - 2))  //边缘处用2*2均值
				{
					noeValue = (int)((pSrc[i*nWidth + j - 1] + pSrc[(i-1)*nWidth + j] + 0.5)/2); //右侧和上侧值的平均
				}
				else
				{
					Gradient   = pSrc[(i-1)*nWidth + j] - pSrc[(i+1)*nWidth + j]; //上侧点减去下侧点
					Compensate = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1])*2
						- pSrc[(i-2)*nWidth + j - 1]
					- pSrc[(i-2)*nWidth + j + 1]
					- pSrc[(i+2)*nWidth + j - 1]
					- pSrc[(i+2)*nWidth + j + 1];
					eeclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					Gradient   = pSrc[i*nWidth + j + 1] - pSrc[i*nWidth + j - 1]; //右侧点减去左侧点
					Compensate = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j])*2
						- pSrc[(i-1)*nWidth + j - 2]
					- pSrc[(i-1)*nWidth + j + 2]
					- pSrc[(i+1)*nWidth + j - 2]
					- pSrc[(i+1)*nWidth + j + 2];
					ooclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					eepred = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j]) << 2;
					oopred = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1]) << 2;

					noeValue = (eeclassifier * (oopred/8) + ooclassifier * (eepred/8))/(eeclassifier + ooclassifier);
				}

				noeValue = CLIP10(noeValue);
				//pDest[i*nWidth + j] = Linear12toGamma10[noeValue] * SCALE_VALUE;
				pDest[i*nWidth + j] = noeValue * SCALE_VALUE;
			}
		}

		//获取G位于偶奇坐标处的值
		for (i = 0; i < nHei; i += 2)
		{
			for (j = 1; j < nWidth; j += 2)
			{
				//pDest[i*nWidth + j] = Linear12toGamma10[pSrc[i * nWidth + j]] * SCALE_VALUE;
				pDest[i*nWidth + j] = pSrc[i * nWidth + j] * SCALE_VALUE;
			}
		}

		//获取G位于奇偶坐标处的值
		for (i = 1; i < nHei; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				//pDest[i*nWidth + j] = Linear12toGamma10[pSrc[i * nWidth + j]] * SCALE_VALUE;
				pDest[i*nWidth + j] = pSrc[i * nWidth + j] * SCALE_VALUE;
			}
		}

		break;
	case  BAYER_GB:
	case  BAYER_GR:
		for (i = 0 ; i < nHei; i += 2)   //计算偶奇位置G分量
		{
			for (j = 1; j < nWidth; j += 2)
			{
				if (i < 2 || j < 2 || i >= (nHei - 2) || j >=(nWidth - 2))  //边缘处用2*2
				{
					neoValue = (int)((pSrc[i * nWidth + j - 1] + pSrc[(i+1)*nWidth + j] + 0.5)/2); //左侧和下侧值的平均
				}
				else
				{
					Gradient   = pSrc[i*nWidth + j - 1] - pSrc[i*nWidth + j + 1];  // 左侧点减去右侧点
					Compensate = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j])*2 
						- pSrc[(i-1)*nWidth + j - 2]
					- pSrc[(i-1)*nWidth + j + 2]
					- pSrc[(i+1)*nWidth + j - 2]
					- pSrc[(i+1)*nWidth + j + 2];
					eeclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					Gradient   = pSrc[(i+1)*nWidth + j] - pSrc[(i-1)*nWidth + j];   // 下侧点减去上侧点
					Compensate = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1]) * 2
						- pSrc[(i-2)*nWidth + j - 1]
					- pSrc[(i-2)*nWidth + j + 1]
					- pSrc[(i+2)*nWidth + j - 1]
					- pSrc[(i+2)*nWidth + j + 1];
					ooclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					eepred =  (pSrc[i * nWidth + j - 1] + pSrc[i * nWidth + j + 1]) << 2;
					oopred =  (pSrc[(i - 1) * nWidth + j] + pSrc[(i + 1) * nWidth + j]) << 2;

					neoValue = (eeclassifier * (oopred/8) + ooclassifier * (eepred/8))/(eeclassifier + ooclassifier);
				}

				neoValue = CLIP10(neoValue);
				pDest[i*nWidth + j] = Linear12toGamma10[neoValue] * SCALE_VALUE;

			}
		}


		for (i = 1; i < nHei; i += 2)  //计算奇偶位置G分量
		{
			for (j = 0; j < nWidth; j += 2)
			{
				if (i < 2 || j < 2 || i >=(nHei - 2) || j >= (nWidth - 2))  //边缘处用2*2均值
				{
					noeValue = (int)((pSrc[i*nWidth + j + 1] + pSrc[(i-1)*nWidth + j] + 0.5)/2); //右侧和上侧值的平均
				}
				else
				{
					Gradient   = pSrc[(i-1)*nWidth + j] - pSrc[(i+1)*nWidth + j]; //上侧点减去下侧点
					Compensate = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1])*2
						- pSrc[(i-2)*nWidth + j - 1]
					- pSrc[(i-2)*nWidth + j + 1]
					- pSrc[(i+2)*nWidth + j - 1]
					- pSrc[(i+2)*nWidth + j + 1];
					eeclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					Gradient   = pSrc[i*nWidth + j + 1] - pSrc[i*nWidth + j - 1]; //右侧点减去左侧点
					Compensate = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j])*2
						- pSrc[(i-1)*nWidth + j - 2]
					- pSrc[(i-1)*nWidth + j + 2]
					- pSrc[(i+1)*nWidth + j - 2]
					- pSrc[(i+1)*nWidth + j + 2];
					ooclassifier = abs(Gradient)*2 + abs(Compensate) + 1;

					eepred = (pSrc[(i-1)*nWidth + j] + pSrc[(i+1)*nWidth + j]) << 2;
					oopred = (pSrc[i*nWidth + j - 1] + pSrc[i*nWidth + j + 1]) << 2;

					noeValue = (eeclassifier * (oopred/8) + ooclassifier * (eepred/8))/(eeclassifier + ooclassifier);
				}

				noeValue = CLIP10(noeValue);
				pDest[i*nWidth + j] = Linear12toGamma10[noeValue] * SCALE_VALUE;
			}
		}

		//获取G位于偶奇坐标处的值
		for (i = 0; i < nHei; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				pDest[i*nWidth + j] = Linear12toGamma10[pSrc[i * nWidth + j]] * SCALE_VALUE;
			}
		}

		//获取G位于奇偶坐标处的值
		for (i = 1; i < nHei; i += 2)
		{
			for (j = 1; j < nWidth; j += 2)
			{
				pDest[i*nWidth + j] = Linear12toGamma10[pSrc[i * nWidth + j]] * SCALE_VALUE;
			}
		}

		break;

	default:
		break;
	}
}


//--------------------------------------------------
/**
插值获得dBayer
\param   pSrc         12位Raw图原始图像buffer指针
\param   nWidth       图像宽
\paran   nHeight      图像高
\Param   pDest        全分辨率dBayer
 return  NULL       
*/
//--------------------------------------------------

void GetdBayer(int *pDest, short *pSrc, int *pFullG,int nWidth, int nHeight)
{
	if (pSrc == NULL || pDest == NULL || pFullG == NULL )
	{
		return ;
	}
	for ( int i = 0; i < nHeight; i ++)
	{
		for (int j = 0; j < nWidth; j ++)
		{
			pDest[i * nWidth + j] = ( (/*Linear12toGamma10[*/pSrc[i * nWidth + j]/*]*/) - (pFullG[i * nWidth + j]/SCALE_VALUE) ) * SCALE_VALUE;  
		}
	}
}

//--------------------------------------------------
/**
dBayer滤波
\param   pSrc         10位Raw图原始图像buffer指针
\param   nWidth       图像宽
\paran   nHeight      图像高
\Param   pDest        输出的滤波后的图像数据
\Param   pBayer       原始图像数据

 return  NULL
*/
//--------------------------------------------------

void dBayerFilter(int *pDest, int *pSrc, short *pBayer,int nWidth, int nHeight)
{
	if ( pDest == NULL || pSrc == NULL)
	{
		return;
	}


	int i = 0;
	int radius[3];
	radius[0] = 1;
	radius[1] = 2;
	radius[2] = 2;

	float sigma[3];
	sigma[0] = 2.0;
	sigma[1] = 2.0;
	sigma[2] = 2.0;

	//int radius[3];
	//radius[0] = 1;
	//radius[1] = 2;
	//radius[2] = 0;

	//float sigma[3];
	//sigma[0] = 1.0;
	//sigma[1] = 2.0;
	//sigma[2] = 2.0;

	float slope = 2;
	float intercept = 1000;

	//图像阈值buffer
	unsigned short *pThArray = new unsigned short[nWidth*nHeight];
	memset(pThArray, 0, nWidth * nHeight * sizeof(unsigned short));

	//参考数据buffer
	int *pRefBuf = new int[nWidth * nHeight];
	memcpy(pRefBuf, pSrc, nWidth * nHeight * sizeof(int));

	for (i = 0; i < 3; i ++)
	{
		if (radius[i] > 0)
		{
			//计算降噪阈值
			ColorBuildGammaNoiseThreshold(pBayer, nWidth, nHeight, sigma[i], slope, intercept, pThArray);

			//滤波
			IterativeSigmaFilter(pDest, pRefBuf, nWidth, nHeight, 2 * radius[i], pThArray);
		}
	}

	delete []pRefBuf;
	delete []pThArray;
	pRefBuf = NULL;
	pThArray = NULL;

}


//--------------------------------------------------
/**
滤波函数
\param   pArray      需要滤波的图像
\param   pRefArray   参考图像(与需要滤波图像相同,保存原始数据)
\param   nWidth      图像宽
\param   nHei        图像高
\param   radius      滤波半径
\param   pThLut      滤波阈值(与图像大小相同Buffer)

 return  状态参数(参考HVSTATUS的定义)  
*/
//--------------------------------------------------
void IterativeSigmaFilter(int *pArray, int *pRefArray, int nWidth,int nHei,int radius,unsigned short *pThArray)
{
	if (pArray == NULL || pRefArray == NULL || pThArray == NULL )
	{
		return ;
	}

	int i = 0;
	int j = 0;
	int x = 0;
	int y = 0;

	int startX = radius;
	int startY = radius;
	int endX   = nWidth - radius;
	int endY   = nHei   - radius;
	int stepX  = radius;
	int stepY  = radius;

	int threshold = 0;
	int mask  = 0;
	int count = 0;

	int sum   =  0;
	int diff  =  0;
	int score =  0;
	int fv    =  0;
	int refValue   =  0;

	int centralPos = 0;
	int pixelPos   = 0;

	int *pBufArray = new int[nWidth*nHei];
    memcpy(pBufArray, pRefArray, nWidth*nHei*sizeof(int));
	
    for (i = startY; i < endY; i ++)
    {
        for (j = startX; j < endX; j ++)
        {
            sum   = 0;
            count = 0;

            centralPos = i*nWidth + j;
            fv         = pBufArray[centralPos];
            refValue   = pRefArray[centralPos];
            threshold  = pThArray[centralPos] * SCALE_VALUE;  // 数据放大到26位，为了保证精度

            for (y = -radius; y <= radius; y += stepY)
            {
                for (x = -radius; x <= radius; x += stepX)
                {
                    pixelPos = (i+y)*nWidth + j + x;

                    if (pixelPos == centralPos)   //位于中心位置，跳出本次循环
					{
						continue;
					}

                    diff  = pBufArray[pixelPos] - fv;
                    score = pBufArray[pixelPos] - refValue;

					//当前像素值与中心像素差的绝对值小于阈值，模板为1，否则为0
                    mask = abs(score) < threshold ? 1:0;

                    sum   += mask * diff; //求模板像素为1的像素与中心像素的差值的和
                    count += mask;
                }
            }

            fv += sum/(count + 1);   //求滤波后的像素值
            pArray[centralPos] = fv;
        }
    }
	
	delete []pBufArray;

}

//--------------------------------------------------
/**
计算dBayer图像降噪阈值
\param   plBayer     lBayer图像，用于估计噪声阈值
\param   nlWidth     lBayer图像的宽
\param   nlHei       lBayer图像的高
\param   scale       尺度值
\param   digitalGain 数字增益
\param   slope       斜率
\param   intercept   截距
\param   pThArray    对应于每个像素点的阈值

 return  状态参数(参考HVSTATUS的定义)  
*/
//--------------------------------------------------
void ColorBuildGammaNoiseThreshold(short *plBayer, int nlWidth, int nlHei,float scale,float slope,float intercept,unsigned short *pThArray)
{
	if (plBayer == NULL || pThArray == NULL)
	{
		return ;
	}

	float xLin = 0.0;
	float yLin = 0.0;

    int  upper = 0;
	int  lower = 0;
	int  i     = 0;
	int  j     = 0;

    int   pixelPos = 0;
    short noiseTable[1024];
	
	//计算阈值查找表
    for (i = 0; i < 1024; i ++)
    {
		//xLin = i;
        xLin = Gamma10toLinear12[i];
        yLin = scale  * sqrt(slope*xLin+intercept);

        yLin = yLin > 1 ? yLin : 1;   //yLin值的范围

        upper = (int)(xLin + yLin + 0.5); //四舍五入
        upper = Linear12toGamma10[CLIP12(upper)];
		//upper = CLIP10(upper);

        lower = (int)(xLin - yLin > 0 ? (xLin - yLin + 0.5):(xLin - yLin - 0.5));
        lower = Linear12toGamma10[CLIP12(lower)];
		//lower = CLIP10(lower);

        noiseTable[i] = MAX(abs(upper - i),abs(i - lower)); //计算查找表
    }
	
	// 根据像素值和查找表获取每个像素点的阈值
    for (i = 0; i < nlHei; i++)
    {
        for (j = 0; j < nlWidth; j++)
        {
            pixelPos = (i * nlWidth + j);
           // pThArray[pixelPos] = noiseTable[CLIP10(plBayer[pixelPos])]; //将12位的数据转换为10位了
			pThArray[pixelPos] = noiseTable[CLIP10(plBayer[pixelPos])]; //将12位的数据转换为10位了
        }
    }

}


//--------------------------------------------------
/**
对dBayer图像插值,并同时构造全分辨率大小的R,G,B分量图像
\param   pSrc           10位Bayer图像
\param   pDest          10位RGB图像
\param   nWidth         图像的宽
\paran   nHeight        图像的高

 return  NULL 
*/
//--------------------------------------------------
void RBInterprate(int* pSrc, int nWidth, int nHeight,int *pldRed,int *pldGreen,int *pldBlue,BAYER_TYPE Bayer_type)
{
	int  i = 0;
	int  j = 0;
	int  PixelPos = 0;

	switch(Bayer_type)
	{
	case BAYER_BG:

		for (i = 0; i < nHeight; i++)
		{
			for (j = 0; j < nWidth; j++)
			{
				PixelPos = i * nWidth + j;

				if (i % 2 == 0 && j % 2 == 0)  //对应B分量
				{
					if (i == 0 || j == 0)      //第一行或第一列
					{
						pldBlue[PixelPos] = pSrc[PixelPos];
						pldGreen[PixelPos] = (pSrc[PixelPos + 1] + pSrc[PixelPos + nWidth]) >> 1;
						pldRed[PixelPos] = pSrc[PixelPos + nWidth + 1];
					}
					else
					{
						pldBlue[PixelPos] = pSrc[PixelPos];

						pldGreen[PixelPos] = (pSrc[PixelPos - nWidth]
							+ pSrc[PixelPos - 1]
							+ pSrc[PixelPos + nWidth]
							+ pSrc[PixelPos + 1]) >> 2;

						pldRed[PixelPos] = (pSrc[PixelPos - nWidth - 1]
							+ pSrc[PixelPos - nWidth + 1]
							+ pSrc[PixelPos + nWidth - 1]
							+ pSrc[PixelPos + nWidth + 1]) >> 2;
					}
				}

				if (i % 2 == 0 && j % 2 == 1) //对应G分量
				{
					if (i == 0 || j == nWidth - 1) //第一行或最后一列
					{
						pldBlue[PixelPos] = pSrc[PixelPos - 1];
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldRed[PixelPos] = pSrc[PixelPos + nWidth];
					}
					else
					{
						pldBlue[PixelPos] = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1]) >> 1;
						pldGreen[PixelPos] = (pSrc[PixelPos] * 4
							+ pSrc[PixelPos - nWidth - 1]
							+ pSrc[PixelPos - nWidth + 1]
							+ pSrc[PixelPos + nWidth - 1]
							+ pSrc[PixelPos + nWidth + 1]) >> 3;
						pldRed[PixelPos] = (pSrc[PixelPos + nWidth] + pSrc[PixelPos - nWidth]) >> 1;
					}
				}

				if (i % 2 == 1 && j % 2 == 0) //对应G分量
				{
					if (i == nHeight - 1 || j == 0) //第一列或最后一行
					{
						pldBlue[PixelPos] = pSrc[PixelPos + 1];
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldRed[PixelPos] = pSrc[PixelPos - nWidth];
					}
					else
					{
						pldBlue[PixelPos] = (pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth]) >> 1;
						pldGreen[PixelPos] = (pSrc[PixelPos] * 4
							+ pSrc[PixelPos - nWidth - 1]
							+ pSrc[PixelPos - nWidth + 1]
							+ pSrc[PixelPos + nWidth - 1]
							+ pSrc[PixelPos + nWidth + 1]) >> 3;
						pldRed[PixelPos] = (pSrc[PixelPos + 1] + pSrc[PixelPos - 1]) >> 1;
					}
				}

				if (i % 2 == 1 && j % 2 == 1) //对应R分量
				{
					if (i == nHeight - 1 || j == nWidth - 1) //最后一行或最后一列
					{
						pldBlue[PixelPos] = pSrc[PixelPos - nWidth - 1];
						pldGreen[PixelPos] = (pSrc[PixelPos - 1] + pSrc[PixelPos - nWidth]) >> 1;
						pldRed[PixelPos] = pSrc[PixelPos];
					}
					else
					{
						pldBlue[PixelPos] = (pSrc[PixelPos - nWidth - 1]
							+ pSrc[PixelPos - nWidth + 1]
							+ pSrc[PixelPos + nWidth - 1]
							+ pSrc[PixelPos + nWidth + 1]) >> 2;

						pldGreen[PixelPos] = (pSrc[PixelPos - 1]
							+ pSrc[PixelPos + 1]
							+ pSrc[PixelPos - nWidth]
							+ pSrc[PixelPos + nWidth]) >> 2;

						pldRed[PixelPos] = pSrc[PixelPos];
					}
				}
			}
		}
		break;
	case BAYER_RG:
		for (i = 0; i < nHeight; i ++)
		{
			for (j = 0; j < nWidth; j ++)
			{
				PixelPos = i * nWidth + j;

				if (i % 2 == 0 && j % 2 == 0) //对应R分量
				{
					if (i == 0 || j == 0) // 第一行或第一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos + nWidth + 1];
						pldGreen[PixelPos] = (pSrc[PixelPos + 1] + pSrc[PixelPos + nWidth]) >> 1;
						pldRed[PixelPos]   = pSrc[PixelPos ];
					}
					else
					{
						pldBlue[PixelPos]  = (pSrc[PixelPos - nWidth - 1] 
						+ pSrc[PixelPos - nWidth + 1]
						+ pSrc[PixelPos + nWidth - 1]
						+ pSrc[PixelPos + nWidth + 1]) >> 2;

						pldGreen[PixelPos] = (pSrc[PixelPos - 1] 
						+ pSrc[PixelPos + 1] 
						+ pSrc[PixelPos - nWidth] 
						+ pSrc[PixelPos + nWidth]) >> 2;
						pldRed[PixelPos]   = pSrc[PixelPos];
					}
				}

				if (i % 2 == 0 && j % 2 == 1) //对应G分量
				{
					if ( i == 0 || j == nWidth - 1) //第一行或最后一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos + nWidth];
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldRed[PixelPos]   = pSrc[PixelPos - 1];
					}
					else
					{
						pldBlue[PixelPos]  = (pSrc[PixelPos + nWidth] + pSrc[PixelPos - nWidth]) >> 1;
						pldGreen[PixelPos] = (pSrc[PixelPos] * 4 
							+ pSrc[PixelPos - nWidth - 1]
						+ pSrc[PixelPos - nWidth + 1]
						+ pSrc[PixelPos + nWidth - 1]
						+ pSrc[PixelPos + nWidth + 1]) >> 3;
						pldRed[PixelPos]   = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1]) >> 1;
					}
				}

				if (i % 2 == 1 && j % 2 == 0) // 对应G分量
				{
					if (i == nHeight - 1 || j == 0) //第一列或最后一行
					{
						pldBlue[PixelPos]  = pSrc[PixelPos + 1];
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldRed[PixelPos]   = pSrc[PixelPos - nWidth];
					}
					else
					{
						pldBlue[PixelPos]  = (pSrc[PixelPos + 1] + pSrc[PixelPos - 1]) >> 1;
						pldGreen[PixelPos] = (pSrc[PixelPos] * 4 
							+ pSrc[PixelPos - nWidth - 1]
						+ pSrc[PixelPos - nWidth + 1]
						+ pSrc[PixelPos + nWidth - 1]
						+ pSrc[PixelPos + nWidth + 1]) >> 3;
						pldRed[PixelPos]   = (pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth]) >> 1;
					}
				}

				if (i % 2 == 1 && j % 2 == 1)  //对应B分量
				{
					if (i == nHeight - 1 || j == nWidth - 1) //最后一行或最后一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos];
						pldGreen[PixelPos] = (pSrc[PixelPos - 1] + pSrc[PixelPos - nWidth]) >> 1;
						pldRed[PixelPos]   = pSrc[PixelPos - nWidth - 1];
					}
					else
					{
						pldBlue[PixelPos]  = pSrc[PixelPos];
						pldGreen[PixelPos] = (pSrc[PixelPos - nWidth]
						+ pSrc[PixelPos - 1] 
						+ pSrc[PixelPos + nWidth] 
						+ pSrc[PixelPos + 1]) >> 2;
						pldRed[PixelPos]   = (pSrc[- nWidth - 1] 
						+ pSrc[PixelPos - nWidth + 1]
						+ pSrc[PixelPos + nWidth - 1]
						+ pSrc[PixelPos + nWidth + 1]) >> 2;	
					}
				}
			}
		}

		break;
	case BAYER_GB:
		for (i = 0; i < nHeight; i ++)
		{
			for (j = 0; j < nWidth; j ++)
			{
				PixelPos = i * nWidth + j;

				if (i % 2 == 0 && j % 2 == 0) //对应G分量
				{
					if (i == 0 || j == 0) // 第一行或第一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos + 1];
						pldRed[PixelPos]   = pSrc[PixelPos + nWidth];
						pldGreen[PixelPos] = pSrc[PixelPos ];
					}
					else
					{
						pldRed[PixelPos]   = (pSrc[PixelPos -nWidth] + pSrc[PixelPos + nWidth] + 1)/2;
						pldBlue[PixelPos]  = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1] + 1)/2;
						pldGreen[PixelPos] =  pSrc[PixelPos];
					}
				}

				if (i % 2 == 0 && j % 2 == 1) //对应B分量
				{
					if ( i == 0 || j == nWidth - 1) //第一行或最后一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos];
						pldGreen[PixelPos] = pSrc[PixelPos - 1];
						pldRed[PixelPos]   = pSrc[PixelPos + nWidth - 1];
					}
					else
					{
						pldBlue[PixelPos]  =  pSrc[PixelPos];
						pldGreen[PixelPos] = (pSrc[PixelPos -nWidth] + pSrc[PixelPos + nWidth] + pSrc[PixelPos-1] + pSrc[PixelPos + 1] + 2) / 4;
						pldRed[PixelPos]   = (pSrc[PixelPos - nWidth -1] + pSrc[PixelPos - nWidth + 1] + pSrc[PixelPos + nWidth -1] + pSrc[PixelPos + nWidth + 1] + 2)/4;
					}
				}

				if (i % 2 == 1 && j % 2 == 0) // 对应R分量
				{
					if (i == nHeight - 1 || j == 0) //第一列或最后一行
					{
						pldBlue[PixelPos]  = pSrc[PixelPos - nWidth + 1];
						pldGreen[PixelPos] = (pSrc[PixelPos + 1] + pSrc[PixelPos -nWidth])/2;
						pldRed[PixelPos]   = pSrc[PixelPos];
					}
					else
					{
						pldBlue[PixelPos]  = (pSrc[PixelPos - nWidth -1] + pSrc[PixelPos - nWidth + 1] + pSrc[PixelPos + nWidth -1] + pSrc[PixelPos + nWidth + 1] + 2)/4;
						pldGreen[PixelPos] = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1] + pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth] + 2)/4;
						pldRed[PixelPos]   = pSrc[PixelPos];
					}
				}

				if (i % 2 == 1 && j % 2 == 1)  //对应G分量
				{
					if (i == nHeight - 1 || j == nWidth - 1) //最后一行或最后一列
					{
						pldBlue[PixelPos]  = pSrc[PixelPos - nWidth];
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldRed[PixelPos]   = pSrc[PixelPos - 1];
					}
					else
					{
						pldBlue[PixelPos]  = (pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth] + 1)/2;
						pldGreen[PixelPos] =  pSrc[PixelPos];
						pldRed[PixelPos]   = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1]+ 1)/2;	
					}
				}
			}
		}

		break;
	case BAYER_GR:
		for (i = 0; i < nHeight; i ++)
		{
			for (j = 0; j < nWidth; j ++)
			{
				PixelPos = i * nWidth + j;

				if (i % 2 == 0 && j % 2 == 0) //对应G分量
				{
					if (i == 0 || j == 0) // 第一行或第一列
					{
						pldRed[PixelPos]  = pSrc[PixelPos + 1];
						pldBlue[PixelPos]   = pSrc[PixelPos + nWidth];
						pldGreen[PixelPos] = pSrc[PixelPos ];
					}
					else
					{
						pldBlue[PixelPos]   = (pSrc[PixelPos -nWidth] + pSrc[PixelPos + nWidth] + 1)/2;
						pldRed[PixelPos]  = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1] + 1)/2;
						pldGreen[PixelPos] =  pSrc[PixelPos];
					}
				}

				if (i % 2 == 0 && j % 2 == 1) //对应R分量
				{
					if ( i == 0 || j == nWidth - 1) //第一行或最后一列
					{
						pldRed[PixelPos]  = pSrc[PixelPos];
						pldGreen[PixelPos] = pSrc[PixelPos - 1];
						pldBlue[PixelPos]   = pSrc[PixelPos + nWidth - 1];
					}
					else
					{
						pldRed[PixelPos]  =  pSrc[PixelPos];
						pldGreen[PixelPos] = (pSrc[PixelPos -nWidth] + pSrc[PixelPos + nWidth] + pSrc[PixelPos-1] + pSrc[PixelPos + 1] + 2)/4;
						pldBlue[PixelPos]   = (pSrc[PixelPos - nWidth -1] + pSrc[PixelPos - nWidth + 1] + pSrc[PixelPos + nWidth -1] + pSrc[PixelPos + nWidth + 1] + 2)/4;
					}
				}

				if (i % 2 == 1 && j % 2 == 0) // 对应B分量
				{
					if (i == nHeight - 1 || j == 0) //第一列或最后一行
					{
						pldRed[PixelPos]  = pSrc[PixelPos - nWidth + 1];
						pldGreen[PixelPos] = (pSrc[PixelPos + 1] + pSrc[PixelPos -nWidth] + 1)/2;
						pldBlue[PixelPos]   = pSrc[PixelPos];
					}
					else
					{
						pldRed[PixelPos]  = (pSrc[PixelPos - nWidth -1] + pSrc[PixelPos - nWidth + 1] + pSrc[PixelPos + nWidth -1] + pSrc[PixelPos + nWidth + 1] + 2)/4;
						pldGreen[PixelPos] = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1] + pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth] + 2)/4;
						pldBlue[PixelPos]   = pSrc[PixelPos];
					}
				}

				if (i % 2 == 1 && j % 2 == 1)  //对应G分量
				{
					if (i == nHeight - 1 || j == nWidth - 1) //最后一行或最后一列
					{
						pldRed[PixelPos]  = pSrc[PixelPos - nWidth];                                                                                                                                                                                                                                     
						pldGreen[PixelPos] = pSrc[PixelPos];
						pldBlue[PixelPos]   = pSrc[PixelPos - 1];
					}
					else
					{
						pldRed[PixelPos]  = (pSrc[PixelPos - nWidth] + pSrc[PixelPos + nWidth] + 1)/2;
						pldGreen[PixelPos] =  pSrc[PixelPos];
						pldBlue[PixelPos]   = (pSrc[PixelPos - 1] + pSrc[PixelPos + 1]+ 1)/2;	
					}
				}
			}
		}

		break;
	default:
		break;
	}
}


//--------------------------------------------------
/**
对dBayer图像插值,并同时构造全分辨率大小的R,G,B分量图像
\param   pRGBImg      24位RGB图像
\param   nWidth       图像宽
\paran   nHei         图像高
\param   phPan_mean   平均后的全分辨率P分量图像
\param   phdRed       全分辨大小的红分量图像
\param   phdGreen     全分辨大小的绿分量图像
\param   phdBlue      全分辨率大小的蓝分量图像

 return  状态参数(参考HVSTATUS的定义)  
*/
//--------------------------------------------------
void Gamma8RGBImg(BYTE *pRGBImg, int nWidth, int nHei, int *phPan_mean, int *phdRed, int *phdGreen, int *phdBlue, int *pGreen)
{
	if (pRGBImg == NULL || phPan_mean == NULL || phdRed == NULL || phdGreen == NULL || phdBlue == NULL)
	{
		return ;
	}

	int R = 0;
	int G = 0;
	int B = 0;

	int i = 0;
	int j = 0;
	int PixelPos = 0;
	int Pos = 0;
	unsigned  short *pRaw = new unsigned short[nWidth * nHei];
	int k = 0;

	for (i = 0; i < nHei; i ++)
	{
		for (j = 0; j < nWidth; j ++)
		{
			//p分量与dBayer插值出的分量的和为最终的RGB分量值
			PixelPos = i * nWidth + j;
			R = ((phPan_mean[PixelPos]  + phdRed[PixelPos])  / SCALE_VALUE) * 0.80 + (pGreen[PixelPos] / SCALE_VALUE) * 0.2; //4800以下
		    G = ((phPan_mean[PixelPos]  + phdGreen[PixelPos])/ SCALE_VALUE) * 0.60+ (pGreen[PixelPos] / SCALE_VALUE) * 0.4;
			B = ((phPan_mean[PixelPos]  + phdBlue[PixelPos]) / SCALE_VALUE) * 0.80 + (pGreen[PixelPos] / SCALE_VALUE) * 0.2;

			/*R = ((phPan_mean[PixelPos] + phdRed[PixelPos]) / SCALE_VALUE)   * 0.60 + (pGreen[PixelPos] / SCALE_VALUE) * 0.4;
			G = ((phPan_mean[PixelPos] + phdGreen[PixelPos]) / SCALE_VALUE)  * 0.70 + (pGreen[PixelPos] / SCALE_VALUE)* 0.3;
			B = ((phPan_mean[PixelPos] + phdBlue[PixelPos]) / SCALE_VALUE)  * 0.60 + (pGreen[PixelPos] / SCALE_VALUE)* 0.4;*/

			if (i % 2 == 0 && j % 2 == 0)
			{
				pRaw[k] = CLIP10(B);
				k++;
			}
			else if (i % 2 == 0 && j % 2 == 1)
			{
				pRaw[k] = CLIP10(G);
				k++;
			}
			else if (i % 2 == 1 && j % 2 == 0)
			{
				pRaw[k] = CLIP10(G);
				k++;
			}
			else if (i % 2 == 1 && j % 2 == 1)
			{
				pRaw[k] = CLIP10(R);
				k++;
			}

			//Pos = 3 * PixelPos;
			//pRGBImg[Pos] = CLIP10(B)>> 2;

			//Pos++;
			//pRGBImg[Pos] = CLIP10(G) >> 2;

			//Pos++;
			//pRGBImg[Pos] = CLIP10(R) >> 2;

			Pos = 3 * PixelPos;
			pRGBImg[Pos] = g_LowLightGamma[CLIP10(B)];

			Pos++;
			pRGBImg[Pos] = g_LowLightGamma[CLIP10(G)];

			Pos++;
			pRGBImg[Pos] = g_LowLightGamma[CLIP10(R)];
		}
	}

	FILE *pWrite = fopen("ProcessRaw.raw", "wb");
	fwrite(pRaw, 1, WIDTH * HEIGHT * 2, pWrite);
	fclose(pWrite);
}

//--------------------------------------------------
/**
  对8位RGB图像进行颜色校正处理

\param   pRGBImg      24位RGB图像
\param   nWidth       图像宽
\paran   nHei         图像高

 return  NULL

*/
//--------------------------------------------------
void ColorCorrection(BYTE *pRGBImg, int nWidth,int nHei)
{
	if (pRGBImg == NULL)
	{
		return ;
	}

	float rr = 1.578125;
	float rg = -0.546875;
	float rb = -0.03125;

	float gr = -0.0234375;
	float gg = 1.2890625;
	float gb = -0.2578125;

	float br = 0;
	float bg = -0.59375;
	float bb = 1.59375;

	int i = 0;
	int j = 0;

	int B = 0;
	int G = 0;
	int R = 0;

	int ccB = 0;
	int ccG = 0;
	int ccR = 0;

	for (i = 0; i < nHei; i ++)
	{
		for (j = 0; j < nWidth; j ++)
		{
			int PixelPos = 3*(i*nWidth + j);

			B = pRGBImg[PixelPos + 0];
			G = pRGBImg[PixelPos + 1];
			R = pRGBImg[PixelPos + 2];

			ccR = (int)(rr*R + rg*G + rb*B);
			ccG = (int)(gr*R + gg*G + gb*B);
			ccB = (int)(br*R + bg*G + bb*B);

			pRGBImg[PixelPos + 0] = CLIP8(ccB);
			pRGBImg[PixelPos + 1] = CLIP8(ccG);
			pRGBImg[PixelPos + 2] = CLIP8(ccR);
		}
	}
}

//--------------------------------------------------
/**
对dBayer图像进行脉冲滤波
\param   pSrc         dBayer图像buffer指针
\param   nWidth       图像宽
\paran   nHeight      图像高
\param   radius       滤波半径

 return  状态参数(参考HVSTATUS的定义)  
*/
//--------------------------------------------------
void ImpulseFilter_dBayer(int *pSrc,int nWidth, int nHeight,int radius)
{
	if (pSrc == NULL)
	{
		return ;
	}
	
	int pixelPos   = 0;
	int centralPos = 0;
	
	int i = 0;
	int j = 0;
	
	int startX = radius;
	int endX   = nWidth  - radius;
	int startY = radius;
	int endY   = nHeight - radius;
	
    int *pData   = pSrc;
	int *pRefBuf = NULL;
	
	pRefBuf = new int[nWidth * nHeight];
	memcpy(pRefBuf,pData,nWidth*nHeight*sizeof(int));
	
	int v11 = 0;
	int v12 = 0;
	int v13 = 0;
	int v21 = 0;
	int v22 = 0;
	int v23 = 0;
	int v31 = 0;
	int v32 = 0;
	int v33 = 0;
	int max = 0;
	int min = 0;

	for (i = startY; i < endY; i ++)
	{
		for (j = startX; j < endX; j ++)
		{
			//取中心像素3*3模板领域内的像素值
			pixelPos = (i - radius)*nWidth + (j - radius);
			v11 = pRefBuf[pixelPos];
				
			pixelPos = (i - radius)*nWidth + j;
			v12 = pRefBuf[pixelPos];
				
			pixelPos = (i - radius)*nWidth + (j + radius);
			v13 = pRefBuf[pixelPos];
				
			pixelPos = i*nWidth + (j - radius);
			v21 = pRefBuf[pixelPos];
				
			centralPos = i*nWidth + j;
			v22 = pRefBuf[centralPos];
				
			pixelPos = i*nWidth + (j + radius);
			v23 = pRefBuf[pixelPos];
				
			pixelPos = (i + radius)*nWidth + (j - radius);
			v31 = pRefBuf[pixelPos];
				
			pixelPos = (i + radius)*nWidth + j;
			v32 = pRefBuf[pixelPos];
				
			pixelPos = (i + radius)*nWidth + (j + radius);
			v33 = pRefBuf[pixelPos];
				
			//求模板领域像素的最大最小值
			max = MAX(v11,v12);
			min = MIN(v11,v12);
			max = MAX(max,v13);
			min = MIN(min,v13);
			max = MAX(max,v21);
			min = MIN(min,v21);
			max = MAX(max,v23);
			min = MIN(min,v23);
			max = MAX(max,v31);
			min = MIN(min,v31);
			max = MAX(max,v32);
			min = MIN(min,v32);
			max = MAX(max,v33);
			min = MIN(min,v33);
				
			//将中心像素值切到(min,max)范围内
			v22 = MIN(v22,max);
			v22 = MAX(v22,min);
				
			//利用调整后的值代替中心像素值
			pData[centralPos] = v22;		
		}
	}

	delete []pRefBuf;

}

void InterpolationGreenofXG16Bit(unsigned short *pSrce, unsigned short * pDest, int nWid, int nHei)
{
	int i = 0;
	int j = 0;
	unsigned short* pRaw = NULL;                           // 指向原图像的指针
	unsigned short *    pRGB = NULL;                           // 指向目标图像的指针
	unsigned short  ushTemp = 0;                              // 中间变量
	int nHeiLen = nHei / 2 - 2;                   // 图像高循环次数
	int nWidLen = nWid / 2 - 2;                   // 图像宽循环次数
	int nRGBRecur = 0;                              // RGB图像指向下一行时移动的步长


	pRaw = pSrce + nWid * 2 + 2;                          // Raw图像的起始位置
	pRGB = pDest + nWid * 2 + 2;                          // RGB图像的起始位置 
	nRGBRecur = 4;                                        // RGB图像指向下一行时移动的步长


														  // 对图像进行G分量插值
	for (i = nHeiLen; i > 0; i--)
	{
		// XG行进行G分量插值
		for (j = nWidLen; j > 0; j--)
		{
			// X点进行G分量插值
			InterGreen16Bit(pRaw, nWid, ushTemp);
			*pRGB = ushTemp;
			pRaw++;
			pRGB++;

			// G点插值
			*pRGB = *pRaw;
			pRaw++;
			pRGB++;
		}
		pRaw += 4;                   // 指向Raw图像的下一行
		pRGB += nRGBRecur;           // 指向RGB图像的下一行

									 // GX行进行G分量插值插值
		for (j = nWidLen; j > 0; j--)
		{
			// G点插值
			*pRGB = *pRaw;
			pRaw++;
			pRGB++;

			// X点进行G分量插值
			InterGreen16Bit(pRaw, nWid, ushTemp);
			*pRGB= ushTemp;
			pRaw++;
			pRGB++;
		}
		pRaw += 4;                  // 指向Raw图像的下一行
		pRGB += nRGBRecur;          // 指向RGB图像的下一行
	}
}

void InterGreen16Bit(unsigned short *pRaw, int nWid, unsigned short &uchGreen)
{
	int nTemp = 0;
	double dDH = 0;
	double dDV = 0;

	double dGHL = 0;
	double dGHR = 0;
	double dGVU = 0;
	double dGVD = 0;

	double dWeightHL = 0;
	double dWeightHR = 0;
	double dWeightVU = 0;
	double dWeightVD = 0;

	double dTH = 0;
	double dMH = 0;
	double dMV = 0;

	dDH = abs(abs(*pRaw - *(pRaw - 1)) - abs(*pRaw - *(pRaw + 1)));
	dDV = abs(abs(*pRaw - *(pRaw - nWid)) - abs(*pRaw - *(pRaw + nWid)));

	dMH = (*pRaw + *(pRaw - 2) + *(pRaw + 2)) / 3;
	dMV = (*pRaw + *(pRaw - 2 * nWid) + *(pRaw + 2 * nWid)) / 3;
	dTH = (dDH / dMH) - (dDV / dMV);
	if (dTH < 0.0)
	{
		dTH = -dTH;
	}

	// 水平方向上梯度计算变量
	int nHX = 0;
	int nHG = 0;
	int nHGR = 0;
	int nHB = 0;

	// 垂直方向上梯度计算变量
	int nVX = 0;
	int nVG = 0;
	int nVGR = 0;
	int nVB = 0;

	int nVertical = 0;
	int nHorizontal = 0;
	//int nTemp = 0;         
	int G2 = *(pRaw - nWid);
	int G4 = *(pRaw - 1);
	int G6 = *(pRaw + 1);
	int G8 = *(pRaw + nWid);

	int nX = 2 * (*(pRaw)) - (*(pRaw - 2)) - (*(pRaw + 2));                    // 水平方向梯度值
	int nY = 2 * (*(pRaw)) - (*(pRaw - 2 * nWid)) - (*(pRaw + 2 * nWid));      // 垂直方向梯度值

																			   // 当前像素点水平方向梯度
	nHX = abs((*(pRaw + 2)) - (*pRaw)) + abs((*(pRaw - 2 * nWid + 2)) - (*(pRaw - 2 * nWid))) + abs((*(pRaw + 2 * nWid + 2)) - (*(pRaw + 2 * nWid)))
		+ abs((*(pRaw - 2)) - (*pRaw)) + abs((*(pRaw - 2 * nWid - 2)) - (*(pRaw - 2 * nWid))) + abs((*(pRaw + 2 * nWid - 2)) - (*(pRaw + 2 * nWid)));

	// G分量水平方向的梯度值
	nHG = abs((*(pRaw + nWid + 2)) - (*(pRaw + nWid))) + abs((*(pRaw + nWid - 2)) - (*(pRaw + nWid)))
		+ abs((*(pRaw - nWid + 2)) - (*(pRaw - nWid))) + abs((*(pRaw - nWid - 2)) - (*(pRaw - nWid)));

	// G分量和当前像素点在水平方向上的梯度
	nHGR = abs((*(pRaw - 1)) + (*(pRaw + 1)) - (*pRaw) * 2);

	// 另一像素点水平梯度
	nHB = abs((*(pRaw + nWid + 1)) - (*(pRaw + nWid - 1)))
		+ abs((*(pRaw - nWid + 1)) - (*(pRaw - nWid - 1)));

	// 水平方向梯度
	nHorizontal = nHX + nHG + nHB + nHGR;

	// 当前像素点垂直方向上梯度值
	nVX = abs((*(pRaw - 2 * nWid)) - (*pRaw)) + abs((*(pRaw - 2 * nWid + 2)) - (*(pRaw + 2))) + abs((*(pRaw - 2 * nWid - 2)) - (*(pRaw - 2)))
		+ abs((*(pRaw + 2 * nWid)) - (*pRaw)) + abs((*(pRaw + 2 * nWid + 2)) - (*(pRaw + 2))) + abs((*(pRaw + 2 * nWid - 2)) - (*(pRaw - 2)));

	// G分量垂直方向的梯度值
	nVG = abs((*(pRaw + 2 * nWid - 1)) - (*(pRaw - 1))) + abs((*(pRaw + 2 * nWid + 1)) - (*(pRaw + 1)))
		+ abs((*(pRaw - 2 * nWid - 1)) - (*(pRaw - 1))) + abs((*(pRaw - 2 * nWid + 1)) - (*(pRaw + 1)));

	// G分量和当前像素点在垂直方向上的梯度
	nVGR = abs((*(pRaw + nWid)) + (*(pRaw - nWid)) - (*pRaw) * 2);

	// 另一像素点垂直梯度
	nVB = abs((*(pRaw - nWid - 1)) - (*(pRaw + nWid - 1)))
		+ abs((*(pRaw - nWid + 1)) - (*(pRaw + nWid + 1)));

	// 垂直方向梯度
	nVertical = nVX + nVG + nVB + nVGR;

	if (nVertical > nHorizontal)
	{
		nTemp = ((2 * (G4 + G6) + nX) >> 2);
	}
	else if (nVertical < nHorizontal)
	{
		nTemp = ((2 * (G2 + G8) + nY) >> 2);
	}
	else
	{
		nTemp = ((G6 + G8 + G2 + G4) >> 2) + ((nX + nY) >> 3);
	}

	uchGreen = CLIP12(nTemp);
}

void RawBGWhiteBalance(short* pRaw, int nWidth, int nHeight)
{
	double dRSum = 0;
	double dG1Sum = 0;
	double dG2Sum = 0;
	double dBSum = 0;
	double dBRatio = 0;
	double dG1Ratio = 0;
	double dG2Ratio = 0;
	double dRRatio = 0;

	for (int i = 0; i < nHeight; i++)
	{
		for (int j = 0; j < nWidth; j++)
		{
			if (i % 2 == 0 && j % 2 == 0)
			{
				dBSum = dBSum + pRaw[i * nWidth + j];
			}
			else if (i % 2 == 0 && j % 2 == 1)
			{
				dG1Sum = dG1Sum + pRaw[i * nWidth + j];
			}
			else if (i % 2 == 1 && j % 2 == 0)
			{
				dG2Sum = dG2Sum + pRaw[i * nWidth + j];
			}
			else if (i % 2 == 1 && j % 2 == 1)
			{
				dRSum = dRSum + pRaw[i * nWidth + j];
			}
		}
	}
	double dValue = 0;
	if (dG1Sum > dG2Sum)
	{
		dValue = dG1Sum;
	}
	else
	{
		dValue = dG2Sum;
	}
	dBRatio = dValue / dBSum;
	dG1Ratio = dValue / dG1Sum;
	dG2Ratio = dValue / dG2Sum;
	dRRatio = dValue / dRSum;

	int nTemp = 0;
	for (int i = 0; i < nHeight; i++)
	{
		for (int j = 0; j < nWidth; j++)
		{
			if (i % 2 == 0 && j % 2 == 0)
			{
				nTemp = pRaw[i * nWidth + j] * dBRatio;
				if (nTemp > 1023)
				{
					nTemp = 1023;
				}
				pRaw[i * nWidth + j] = (short)nTemp;
			}
			else if (i % 2 == 0 && j % 2 == 1)
			{
				nTemp = pRaw[i * nWidth + j] * dG1Ratio;
				if (nTemp > 1023)
				{
					nTemp = 1023;
				}
				pRaw[i * nWidth + j] = (short)nTemp;
			}
			else if (i % 2 == 1 && j % 2 == 0)
			{
				nTemp = pRaw[i * nWidth + j] * dG2Ratio;
				if (nTemp > 1023)
				{
					nTemp = 1023;
				}
				pRaw[i * nWidth + j] = (short)nTemp;
			}
			else if (i % 2 == 1 && j % 2 == 1)
			{
				nTemp = pRaw[i * nWidth + j] * dRRatio;
				if (nTemp > 1023)
				{
					nTemp = 1023;
				}
				pRaw[i * nWidth + j] = (short)nTemp;
			}
		}
	}
}
//--------------------------------------------------
/**
一维卷积函数,这里用来实现高斯滤波
\param   pArray       需要进行卷积的矩阵(图像分量矩阵)
\param   nWidth       矩阵宽
\paran   nHeight      矩阵高
\param   pkernel      卷积核
\param   nKernelsize  卷积核长度
\param   edirection   卷积方向

return  NULL
*/
//--------------------------------------------------
void Convolve1D(int *pArray, int nWidth, int nHeight, float *pKernel, int nkernelsize, bool edirection)
{
	if (pArray == NULL || pKernel == NULL)
	{
		return;
	}

	int pixelPos = 0;
	int centralPos = 0;
	int radius = nkernelsize / 2;

	int i = 0;
	int j = 0;
	int step = 1;
	int x = 0;
	int y = 0;

	int startX = radius;
	int endX = nWidth - radius;
	int startY = radius;
	int endY = nHeight - radius;
	float fv = 0.0;

	float *rKernel = NULL;
	rKernel = (float*)malloc(nkernelsize * sizeof(float));
	if (rKernel == NULL)
	{
		return;
	}

	//核翻转
	for (i = 0; i < nkernelsize; i++)
	{
		rKernel[i] = pKernel[nkernelsize - 1 - i];
	}

	//拷贝原始数据
	int  *pBuf = 0;
	pBuf = new int[nWidth * nHeight];
	memcpy(pBuf, pArray, nWidth * nHeight * sizeof(int));

	//水平方向卷积
	if (edirection == 1)
	{
		for (i = 0; i < nHeight; i++)
		{
			for (j = startX; j < endX; j++)
			{
				fv = 0;
				for (x = -radius; x <= radius; x += step)
				{
					pixelPos = i * nWidth + j + x;
					fv += pBuf[pixelPos] * rKernel[x + radius];
				}
				centralPos = i * nWidth + j;
				pArray[centralPos] = fv;
			}
		}
	}
	else if (edirection == 0) //垂直方向卷积
	{
		for (i = 0; i < nWidth; i++)
		{
			for (j = startY; j < endY; j++)
			{
				fv = 0;
				for (y = -radius; y <= radius; y += step)
				{
					pixelPos = (j + y) * nWidth + i;
					fv += pBuf[pixelPos] * rKernel[y + radius];
				}
				centralPos = j*nWidth + i;
				pArray[centralPos] = fv;
			}
		}
	}

	//释放内存
	free(rKernel);
	delete[]pBuf;

}

void WhiteBalance(short *pSrc, int nWidth, int nHeight, float fRatioR, float fRatioB, BAYER_TYPE Bayer_type)
{

	if (pSrc == NULL)
	{
		return;
	}

	int i = 0;
	int j = 0;

	switch (Bayer_type)
	{
	case BAYER_BG:
		for (i = 0; i < nHeight; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				pSrc[i * nWidth + j] = CLIP12((int)(pSrc[i * nWidth + j] * fRatioB));
				pSrc[i * nWidth + nWidth + j + 1] = CLIP12((int)(pSrc[i * nWidth + nWidth + j + 1] * fRatioR));
			}
		}

		break;
	case BAYER_GB:
		for (i = 0; i < nHeight; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				pSrc[i * nWidth + j + 1] = CLIP12((int)(pSrc[i * nWidth + j + 1] * fRatioB));
				pSrc[i * nWidth + nWidth + j] = CLIP12((int)(pSrc[i * nWidth + nWidth + j] * fRatioR));
			}
		}

		break;
	case  BAYER_GR:
		for (i = 0; i < nHeight; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				pSrc[i * nWidth + j + 1] = CLIP12((int)(pSrc[i * nWidth + j + 1] * fRatioR));
				pSrc[i * nWidth + nWidth + j] = CLIP12((int)(pSrc[i * nWidth + nWidth + j] * fRatioB));
			}
		}

		break;
	case BAYER_RG:
		for (i = 0; i < nHeight; i += 2)
		{
			for (j = 0; j < nWidth; j += 2)
			{
				pSrc[i * nWidth + j] = CLIP12((int)(pSrc[i * nWidth + j] * fRatioR));
				pSrc[i * nWidth + nWidth + j + 1] = CLIP12((int)(pSrc[i * nWidth + nWidth + j + 1] * fRatioB));
			}
		}

		break;
	default:
		break;
	}
}






